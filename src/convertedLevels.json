{"levels":{"0":{"name":"hello","instruction":"Найди и исправь все стилевые ошибки в коде. Кликай мышкой по ошибкам.\nКаждая найденная ошибка: +1 балл.","learning":true,"packageId":0,"code":"void Main()\n{\n    Console.WriteLine(\"Enter your name: \");\n    var {{0}} = Console.ReadLine();\n    Console.WriteLine(\"Hello, \" + {{0}});\n}","bugs":{"0":{"code":"veryBadVariableName_clickIt","type":"naming","description":"Длинное и ужасное имя переменной!","replace":"name"}}},"1":{"name":"GetThem","instruction":"Качественно выбранные имена — то что делает ваш код понятнее!","learning":true,"packageId":0,"code":"List<Position> {{0}}(List<Cell> {{1}})\n{\n\tvar {{2}} = new List<Position>();\n\tforeach (var cell in {{1}})\n\t{\n\t\tif (cell.IsEmpty) \n\t\t\t{{2}}.Add(cell.Position);\n\t}\n\treturn {{2}};\n}","bugs":{"0":{"code":"GetThem","type":"naming","description":"Не используйте местоимения в именах. Это совсем не добавляет понятности.","replace":"GetEmptyPositions"},"1":{"code":"theBigList","type":"naming","description":"Имя должно отражать семантику, а не тип переменной. Имена вида s, list, array не дают полезной информации читателю.","replace":"allCells"},"2":{"code":"list1","type":"naming","description":"Имя должно отражать семантику, а не тип переменной. Имена вида s, list, array не дают полезной информации читателю.","replace":"emptyPositions"}}},"2":{"name":"ViewsPerSecond","instruction":"А что ещё, кроме качественных имен может сделать код понятнее?","learning":true,"packageId":0,"code":"double GetViewsPerSecond(IEnumerable<PageView> views, DateTime {{0}})\n{\n\tvar {{1}} = {{2}};\n\tvar viewsCount = views.Count(v => v.Timestamp.Date == {{0}});\n\treturn (double)viewsCount / {{1}};\n}","bugs":{"0":{"code":"t","type":"naming","description":"В именах стоит отражать существенные особенности. \nНапример, если переменная типа DateTime хранит только дату, можно назвать ее date.","replace":"date"},"1":{"code":"n","type":"naming","description":"Имя переменной должно отражать семантику. \nСтарайтесь избегать однобуквенных имен. Общее правило: чем больше область видимости — тем подробнее должно быть имя.","replace":"secondsInDay"},"2":{"code":"86400","type":"other","description":"Иногда, арифметические выражения понятнее, чем значение этого выражения.\nЗапись 24 * 60 * 60 проще проверить на корректность, чем 86400.","replace":"24 * 60 * 60"}}},"3":{"name":"rstr","instruction":"Осторожнее — начиная с этого уровня, за каждый неверный клик и каждую подсказку вы будете терять один балл!","packageId":1,"code":"var {{0}} = Console.ReadLine();\nvar {{1}} = false;\nfor(var charIndex = 0; charIndex < {{0}}.Length; charIndex++)\n{\n\tif ({{1}} || {{0}}[charIndex] != '\\\\')\n\t\tConsole.Write({{0}}[charIndex]);\n\t{{1}} = {{0}}[charIndex] == '\\\\';\n}","bugs":{"0":{"code":"rstr","type":"naming","description":"Избегайте труднпрзнсимых имен и кодирования, понятного лишь вам.","replace":"line"},"1":{"code":"flag","type":"naming","description":"Не называйте булевы переменные flag, f и подобными именами.\nУ каждого \"флага\" есть смысл, который и нужно отразить в имени.","replace":"escaped"}}},"4":{"name":"bigrams","instruction":"Придерживайтесь общепринятого стиля именования для текущего языка программирования.","packageId":1,"code":"List<string> GetBigrams(IList<string> words)\n{\n\tvar {{0}} = words.Count - 1;\n\tvar {{1}} = new string[{{0}}];\n\tfor (var {{2}} = 0; {{2}} < {{0}}; {{2}}++)\n\t\t{{1}}[{{2}}] = words[{{2}}] + \" \" + words[{{2}} + 1];\n\treturn {{1}}.Distinct().ToList();\n}","bugs":{"0":{"code":"colBigrams","type":"naming","description":"Не используйте русские слова в именах (если только вы не программируете на 1C).\nЧитая код, программисты ожидают видеть английские имена, \nпоэтому написанные транслитом русские слова могут быть восприняты неправильно.\nНапример, в данном случае col (количество) легко спутать с сокращением от слова column.","replace":"bigramsCount"},"1":{"code":"bigrams_list","type":"naming","description":"В C# для составных имен принято использовать стиль CamelCase, и не использовать snake_case.","replace":"bigrams"},"2":{"code":"I","type":"naming","description":"В C# имена локальных переменных принято начинать с маленькой буквы.\nНарушение таких, казалось бы, несущественных правил часто сильно раздражает опытных программистов.","replace":"i"}}},"5":{"name":"arg","instruction":"В имени нужно отражать полезный для понимания смысл и стараться избегать слов заместителей с неопределенным смыслом.","packageId":1,"code":"static void Main(string[] args)\n{\n\tvar {{0}} = args.Length > 0 ? args[0] : defaultFilename;\n\tDateTime lastWriteTime = new FileInfo({{0}}).LastWriteTime;\n\tbool {{1}} = lastWriteTime > DateTime.Now - TimeSpan.FromSeconds(1);\n\t{{2}}({{0}}, {{1}});\n\tConsole.WriteLine(lastWriteTime);\n}","bugs":{"0":{"code":"arg","type":"naming","description":"Отражайте в имени то, что важно при дальнейшем использовании.\nВ данном случае то, что это имя входного файла важнее того, что оно получено из аргументов командной строки.","replace":"inputFile"},"1":{"code":"check","type":"naming","description":"Имя 'check' почти всегда можно улучшить. Сообщите в имени, что именно проверяется.","replace":"recentlyModified"},"2":{"code":"Handle","type":"methods","description":"Handle — слово заместитель, не добавляющее смысла. В чем именно заключается \"обработка\"? Отразите это в имени вместо слова Handle.","replace":"ConvertFileToJson"}}},"6":{"name":"manager","instruction":"Продолжаем охоту на слова без смысла.","packageId":1,"code":"public interface {{0}}\n{\n\tJson JsonFromXml(XmlDocument prices);\n\tXmlDocument XmlFromJson(Json prices);\n}","bugs":{"0":{"code":"IPriceManager","type":"naming","description":"Manager — слово заместитель, не добавляющее смысла. Часто его можно заменить на что-то более осмысленное.\nНапример, менеджер по продажам может стать продавцом консультантом.","replace":"IPriceFormatConverter"}}},"7":{"name":"CopyChars","instruction":"Проблемы с именами в этом коде очевидны. Но тут есть кое-что еще!","packageId":1,"code":"void CopyChars(char[] {{0}}, char[] {{1}})\n{\n\t{{2}}for(var i = 0; i < {{0}}.Length; i++)\n\t\t{{1}}[i] = {{0}}[i];\n}","bugs":{"0":{"code":"array1","type":"naming","description":"Имена с номерами на конце — это антипаттерн.\nВместо добавления номеров старайтесь отразить в именах суть различия.","replace":"source"},"1":{"code":"array2","type":"naming","description":"Функцию с непонятными именами аргументов неудобно использовать.","replace":"destination"},"2":{"code":"//copy arrays item by item.\n\t","type":"comments","description":"Нет смысла писать комментарии, повторяющие код.","replace":""}}},"8":{"name":"English","instruction":"В составных именах очень легко случайно продемонстрировать незнание английского :-)","packageId":1,"code":"private string {{0}};\n\nprivate string outputDirectory;\n\npublic enum {{1}} \n{\n\tHigh,\n\tMedium,\n\tLow\n}\n","bugs":{"0":{"code":"directoryInput","type":"naming","description":"directoryInput с английского — это ввод директории. Входная директория — это inputDirectory.","replace":"inputDirectory"},"1":{"code":"QualityRender","type":"naming","description":"Нарушение правильного порядка слов в составных именах — частая ошибка программистов \nсо слабым знанием английского.\nКачество рендера — это QualityOfRender или просто RenderQuality.","replace":"RenderQuality"}}},"9":{"name":"ShareIfYouLike","instruction":"Автору будет приятно, если вы поделитесь ссылкой на эту игру с коллегами.\nЗаранее спасибо! :-)","packageId":1,"code":"if (you.Like(this.Game))\n{\n\tyou.Tweet();\n\tyou.Post();\n\tyou.Share();\n}\nelse\n{\n\tyou.{{0}};\n}\n","bugs":{"0":{"code":"H4Te_AUth0R()","type":"naming","description":"Ненависть — плохое чувство! :-)","replace":"EmailAuthor(\"pe@kontur.ru\")"}}},"10":{"name":"Chessboard","instruction":"Время закрепить все полученные на предыдущих уровнях знания!","packageId":1,"code":"enum {{0}}\n{ \n\tBlack, \n\tWhite\n}\n\nclass Chessboard \n{\n\tprivate {{0}}[,] {{1}};\n\tprivate int {{2}};\n\n\tpublic Chessboard(int {{3}}) \n\t{\n\t\tthis.{{2}} = {{3}};\n\t\tthis.{{1}} = new {{0}}[{{2}},{{2}}];\n\t\t{{4}}\n\t\tfor(var {{5}} = 0; {{5}} < {{2}}; {{5}}++)\n\t\t\tfor(var {{6}} = 0; {{6}} < {{2}}; {{6}}++) \n\t\t\t{\n\t\t\t\tbool isBlack = ({{5}} + {{6}}) % 2 == 0;\n\t\t\t\t{{1}}[{{5}}, {{6}}] = isBlack ? {{0}}.Black : {{0}}.White;\n\t\t\t}\n\t}\n}\n","bugs":{"0":{"code":"ColorCell","type":"naming","description":"Нарушение правильного для английского языка порядка слов в составных именах — частая ошибка программистов \nсо слабым знанием английского.\nColorCell — это цветная клетка, а цвет клетки — CellColor.\nНе путайте — не вводите в замешательство читающих.","replace":"CellColor"},"1":{"code":"array","type":"naming","description":"Имя должно отражать семантику, а не тип переменной. Имена вида s, list, array не дают полезной информации читателю.","replace":"cellColors"},"2":{"code":"m_brdSz","type":"naming","description":"Не используйте закодированные или труднопроизносимые имена. Вам их придется произносить или хотя бы мысленно проговаривать!","replace":"size"},"3":{"code":"n","type":"naming","description":"В данном контексте, n может обозначать как размер шахматной доски, так и количество фигур на доске или номер доски.\nИмя size устранит эту неоднозначность.","replace":"size"},"4":{"code":"//Fill board with black and white colors","type":"comments","description":"Комментарии повторяющие код не имеют смысла.","replace":""},"5":{"code":"a","type":"naming","description":"Для обозначения координат вместо i, j и a, b лучше использовать предсказуемые и понятные x, y. ","replace":"y"},"6":{"code":"b","type":"naming","description":"Избегайте необходимости мысленного декодирования при чтении кода.","replace":"x"}}},"11":{"name":"Initialization","instruction":"Переменные и классы — это сущности, а методы — действия. Имейте это в виду!","packageId":1,"code":"public void {{0}}(int boardSize)\n{\n\tLog(\"Board initialization...\");\n\tthis.piecesCount = 0;\n\tthis.board = {{1}}(boardSize, boardSize);\n\tLog(\"Board initialization finished\");\n}","bugs":{"0":{"code":"Initialization","type":"methods","description":"Методы — это действия, называйте их глаголами или глагольными фразами.","replace":"InitializeBoard"},"1":{"code":"Board","type":"methods","description":"Методы — это действия, называйте их глаголами или глагольными фразами.","replace":"CreateBoard"}}},"12":{"name":"GetSet","instruction":"Имена должны выполнять обещания и не вводить читателя в замешательство.","packageId":1,"code":"void {{0}}()\n{\n\tvar user = Environment.UserName;\n\tthis.factory = {{1}}(user);\n}\n\nTimeSpan GetTimeout()\n{\n\treturn this.timeout;\n}\n\nvoid {{2}}()\n{\n\tvar sectionName = systemName + \"/timeout\";\n\tthis.timeout = ReadSettings(sectionName).Timeout;\n}","bugs":{"0":{"code":"GetFactory","type":"methods","description":"Методы GetXXX, CreateXXX, ReadXXX должны возвращать результат.\nvoid-методы, инициализирующие поля класса лучше так не называть.","replace":"InitFactory"},"1":{"code":"FactoryCreator","type":"methods","description":"Методы — это действия, называйте их глаголами или глагольными фразами.","replace":"CreateFactory"},"2":{"code":"SetTimeout","type":"methods","description":"Методы SetXXX должны принимать устанавливаемое значение в качестве аргумента. \nМетоды без аргументов лучше так не называть.","replace":"InitTimeoutFromSettings"}}},"13":{"name":"SplitMethod","instruction":"Имена переменных и методов тут в порядке. Но не только это делает код хорошим!","packageId":1,"code":"void Main(string[] args)\n{\n\tstring[] inputLines = File.ReadAllLines(args[0]);\n\tstring outputPath = args[1];\n\tif (Directory.Exists(outputPath))\n\t\toutputPath = Path.Combine(outputPath, Path.GetFileName(args[0]));\n\t{{0}}\n\tvar escapedLines = inputLines.Select(s => s.Replace(@\"\", @\"\\\"));\n\tvar outputText = string.Join(\"\\n\", escapedLines);\n\tFile.WriteAllText(outputPath, outputText);\n\tConsole.WriteLine(\"{0} characters\", outputText.Length);\n}","bugs":{"0":{"code":"//Convert file","type":"methods","description":"Вместо комментария, разделяющего код на две фазы, стоит сделать настоящее разделение кода на методы.\nКаждый метод должен делать ровно одну вещь. Если вы можете естественным образом разбить один метод на два — сделайте это!\n","replace":"ConvertFile(inputLines, outputPath);\n}\n\nvoid ConvertFile(IEnumerable<string> inputLines, string outputPath)\n{"}}},"14":{"name":"CommentExplainCode","instruction":"Крохотные методы в одну-две строки часто могут значительно повысить читаемость кода.","packageId":1,"code":"{{0}}\nif ({{1}}))\n\tPay(employee, fullBenefitsAmount); {{2}}\nelse\n\tPay(employee, reducedAmount);","bugs":{"0":{"code":"//If employee deserves full benefits","type":"comments","description":"Вместо поясняющего комментария лучше изменить код так, чтобы в комментарии не было нужды.","replace":""},"1":{"code":"employee.IsHourly() && employee.Age > 65 || employee.HasSpecialReward","type":"methods","description":"Сложные булевы выражения стоит выделять в методы или вспомогательные переменные, давая им говорящие названия. Это улучшит читаемость.","replace":"employee.DeservesFullBenefits()"},"2":{"code":"//Pay largeAmount","type":"comments","description":"Комментарии повторяющие код не нужны. Они легко могут устареть!","replace":""}}},"15":{"name":"endComments","instruction":"Как вы уже поняли, далеко не все комментарии полезны!","packageId":1,"code":"void Main(string[] args)\n{\n\ttry\n\t{\n\t\tvar linesCount = 0;\n\t\tvar charsCount = 0;\n\t\tvar lines = File.ReadAllLines(args[0]);\n\t\tforeach(var line in lines)\n\t\t{\n\t\t\tlinesCount++;\n\t\t\tcharsCount += line.Length;\n\t\t} {{0}}\n\t\tConsole.WriteLine(\"linesCount = \" + linesCount);\n\t\tConsole.WriteLine(\"charsCount = \" + charsCount);\n\t} {{1}}\n\tcatch (Exception e)\n\t{\n\t\tConsole.WriteLine(\"Error: \" + e.Message);\n\t} {{2}}\n}","bugs":{"0":{"code":"//foreach","type":"comments","description":"Комментарии вида 'конец цикла', 'конец функции' и подобные бессмысленны. ","replace":""},"1":{"code":"//try","type":"comments","description":"Для коротких функций такие комментарии не нужны, а длинные функции лучше разбить на несколько более коротких.","replace":""},"2":{"code":"//catch","type":"comments","description":"Современные среды разработки и программистские редакторы умеют подсвечивать парные скобки. Это надежнее таких комментариев.","replace":""}}},"16":{"name":"nameInsteadOfComment","instruction":"Но не спешите удалять все комментарии из вашего кода. Бывают и полезные!","packageId":1,"code":"//format matched: hh:mm:ss, MMM dd, yyyy\nprivate Regex timeRegex = new Regex(@\"\\d*:\\d*:\\d*, \\w* \\d*, \\d*\");\n\nResponder {{0}}","bugs":{"0":{"code":"GetResponder(); //Returns the Responder being tested.","type":"naming","description":"Если появляется желание написать поясняющий комментарий к методу, стоит вместо этого постараться придумать более удачное имя методу.","replace":"GetTestResponder();"}}},"17":{"name":"ExplainCompare","instruction":"Хорошие комментарии должны объяснять намерения программиста в тех случаях, когда их сложно выразить непосредственно кодом.","packageId":1,"code":"{{0}}\npublic int CompareTo(object o)\n{\n\tvar other = o as WikiPagePath;\n\tif(other != null)\n\t{\n\t\t{{1}}\n\t\tstring thisNames = string.Join(\"\", this.Names);\n\t\tstring otherNames = string.Join(\"\", other.Names);\n\t\treturn thisNames.CompareTo(otherNames);\n\t}\n\treturn 1; // WikiPagePath should be greater than any other wrong type.\n} {{2}}","bugs":{"0":{"code":"//comparison of this and other object","type":"comments","description":"Бессмысленно писать в комментарии то, что итак понятно из названия метода.","replace":""},"1":{"code":"//compares concatenated names of this and others","type":"comments","description":"Комментарии дословно повторяющие код бессмысленны.","replace":""},"2":{"code":"//end of CompareTo","type":"comments","description":"Комментарии вида 'конец цикла', 'конец функции' и подобные бессмысленны. \nДля коротких функций они не нужны, а длинные функции лучше разбить на несколько более коротких, вместо написания таких комментариев.","replace":""}}},"18":{"name":"XMLDoc","instruction":"А что вы думаете о спец-комментариях — XML-документации и комментариях с историей изменений файла?","packageId":1,"code":"{{0}}namespace Logger\n{\n\t///<summary>Implement Logger to provide customized event filtering</summary>\n\t///<remarks>\n\t///<para>\n\t///Users should implement this interface to implement customized logging\n\t///event filtering. Note that <see cref=\"Logger.Repository.Hierarchy.Logger\"/>\n\t///and <see cref=\"Logger.Appender.AppenderSkeleton\"/>, the parent class of all\n\t///standard appenders, have built-in filtering rules. It is suggested that you\n\t///first use and understand the built-in rules before rushing to write\n\t///your own custom filters.\n\t///</para>\n\t///</remarks>\n\tpublic interface IFilter : IOptionHandler\n\t{\n\t\t{{1}}\n\t\tFilterDecision Decide(LoggingEvent loggingEvent);\n\n\t\t{{2}}IFilter NextInChain { get; set; }\n\t}\n}","bugs":{"0":{"code":"/*Changes (from 11-Oct-2011)\n* --------------------------\n* 12-Sep-2011 : Fix bug\n* 11-Oct-2011 : Move implementation to another file\n* 05-Nov-2011 : Add XML comments \n*/\n","type":"comments","description":"Когда-то очень давно был смысл писать комментарии с историей изменения файла.\nНо сейчас вместо таких комментариев лучше использовать систему контроля версий и писать понятные сообщения к коммитам.","replace":""},"1":{"code":"///<summary>Make a decision about logging event.</summary>\n\t\t///<param name=\"loggingEvent\">The LoggingEvent to decide upon</param>\n\t\t///<returns>The decision of the filter</returns>","type":"comments","description":"XML-комментарии не несущие новой информации бесполезны.","replace":""},"2":{"code":"///<summary>Property to get and set the next filter</summary>\n\t\t///<value>The next filter in chain</value>\n\t\t","type":"comments","description":"Не пишите XML-комментарий только для того, чтобы он был. В наличии комментария должен быть какой-то смысл.","replace":""}}},"19":{"name":"collision","instruction":"Время закрепить освоенные знания!","packageId":1,"code":"{{0}}\nvoid {{1}}(GameObject hero, GameObject enemy)\n{\n\t{{2}}\n\t{\n\t\thero.Life--;\n\t\tif (!hero.IsAlive && OnHeroDeath != null) {{3}}\n\t\t\tOnHeroDeath(hero);\n\t}\n}","bugs":{"0":{"code":"///<summary>Обрабатывает столкновение героя с врагом</summary>","type":"comments","description":"XML-комментарии бессмысленны, если не несут новую информацию.","replace":""},"1":{"code":"CollisionHandler","type":"methods","description":"Методы — это действия, называйте их глаголами или глагольными фразами.","replace":"HandleCollision"},"2":{"code":"//If hero and enemy collided\n\tif ((hero.X-enemy.X)*(hero.X-enemy.X) + (hero.Y-enemy.Y)*(hero.Y-enemy.Y) \n\t\t< (hero.Radius + enemy.Radius)*(hero.Radius + enemy.Radius))","type":"comments","description":"Не используйте комментарии там, где можно выделить метод с говорящим именем.","replace":"if (Collided(hero, enemy))"},"3":{"code":"//нужно оповестить подписчиков","type":"comments","description":"Комментарии дословно повторяющие код бессмысленны.","replace":""}}},"20":{"name":"LoadMap","instruction":"Последний уровень! По законам жанра тут должно быть много кода!","packageId":1,"code":"///<param name=\"path\">\n/// Path to file or directory with map description. \n/// If path is a path to directory, file default.map is used.\n///</param>\nGameMap LoadMap(string path)\n{\n\tvar {{0}} = Directory.Exists(path) \n\t\t? Path.Combine(path, \"default.map\") \n\t\t: path;\n\tvar lines = File.ReadAllLines({{0}});\n\tvar height = lines.Length;\n\tvar width = lines[0].Length;\n\t{{1}}\n\tvar map = new GameMap(width, height{{2}}\n\tfor(var y=0; y<height; y++)\n\t\tfor(var x=0; x<{{3}}; x++)\n\t\t{\n\t\t\t{{4}}\n\t\t\tmap.Put(x, y, obj);\n\t\t}\n\treturn map;\n}","bugs":{"0":{"code":"Filename","type":"naming","description":"В C# локальные переменные принято называть с маленькой буквы.","replace":"filename"},"1":{"code":"//Initialize map","type":"comments","description":"При виде комментария, разделяющего метод на смысловые части, стоит вынести эти смысловые части в отдельные методы.","replace":""},"2":{"code":") \n\t\t\t\t{\n\t\t\t\t\tScore = 0,\n\t\t\t\t\tHeroLifesCount = 3,\n\t\t\t\t\tTime = 0,\n\t\t\t\t}; ","type":"methods","description":"Логику инициализации полей карты лучше переместить в конструктор класса карты.","replace":");"},"3":{"code":"lines[0].Length","type":"other","description":"Устраняйте дублирование. Это делает код  понятнее и надежнее.","replace":"width"},"4":{"code":"//============Select object to put in (x, y) cell;\n\t\t\tGameObject obj = null;\n\t\t\tswitch (lines[y][x])\n\t\t\t{\n\t\t\t\tcase 'H': \n\t\t\t\t\tobj = new Hero();\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tobj = new Wall();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tobj = new Monster();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//============Put created object on map","type":"methods","description":"Разделительные комментарии вроде такого часто показывают, что программист поленился выделить вспомогательный метод.","replace":"var obj = CreateGameObjectFromChar(lines[y][x]);"}}}}}